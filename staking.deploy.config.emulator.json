{
  "Codes": {
    "Transactions": {
      "Stake": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(flowAmount: UFix64) {\n    prepare(userAccount: AuthAccount) {\n        let flowVault = userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!\n        let inVault <- flowVault.withdraw(amount: flowAmount) as! @FlowToken.Vault\n        \n        let outVault <- LiquidStaking.stake(flowVault: <-inVault)\n\n        var stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        if stFlowVaultRef == nil {\n            userAccount.save(<- stFlowToken.createEmptyVault(), to: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Receiver}>(stFlowToken.tokenReceiverPath, target: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Balance}>(stFlowToken.tokenBalancePath, target: stFlowToken.tokenVaultPath)\n\n            stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        }\n\n        stFlowVaultRef!.deposit(from: <-outVault)\n    }\n}",
      "Unstake": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(stFlowAmount: UFix64) {\n    prepare(userAccount: AuthAccount) {\n        var stFlowVault = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)!\n        let inVault <- stFlowVault.withdraw(amount: stFlowAmount) as! @stFlowToken.Vault\n        \n        let voucher <- LiquidStaking.unstakeSlowly(stFlowVault: <-inVault)\n        log(\"--> unstake slowly stFlow \".concat(stFlowAmount.toString()))\n        log(\"--> could get Flow in the future: \".concat(voucher.lockedFlowAmount.toString()))\n\n        var voucherCollectionRef = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n        if voucherCollectionRef == nil {\n            destroy <- userAccount.load<@AnyResource>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n            userAccount.unlink(LiquidStaking.UnstakingVoucherCollectionPublicPath)\n\n            userAccount.save(<-LiquidStaking.createEmptyUnstakingVoucherCollection(), to: LiquidStaking.UnstakingVoucherCollectionPath)\n            userAccount.link<&{LiquidStaking.UnstakingVoucherCollectionPublic}>(LiquidStaking.UnstakingVoucherCollectionPublicPath, target: LiquidStaking.UnstakingVoucherCollectionPath)\n            voucherCollectionRef = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n        }\n        voucherCollectionRef!.deposit(voucher: <-voucher)\n    }\n}",
      "Claim": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(voucherIndex: UInt32) {\n    prepare(userAccount: AuthAccount) {\n        var voucherCollection = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)!\n        let voucher <-voucherCollection.withdraw(index: voucherIndex)\n\n        let flowVault <- LiquidStaking.cashingUnstakingVoucher(voucher: <-voucher)\n        log(\"--> cashing voucher\")\n        log(\"--> get flow: \".concat(flowVault.balance.toString()))\n\n        userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!.deposit(from: <-flowVault)\n    }\n}"
    },
    "Scripts": {
      "QueryLiquidStakingInfos": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowIDTableStaking from 0xf8d6e0586b0a20c7\nimport FlowEpoch from 0xf8d6e0586b0a20c7\n\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport LiquidStaking from 0xf8d6e0586b0a20c7\nimport DelegatorManager from 0xf8d6e0586b0a20c7\n\npub fun main(userAddr: Address?): {String: AnyStruct} {\n    let currentSnapshot = DelegatorManager.borrowEpochSnapshot(at: DelegatorManager.quoteEpochCounter)\n    \n\n    var voucherInfos: [AnyStruct]? = nil\n    if userAddr != nil {\n        let voucherCollectionRef = getAccount(userAddr!).getCapability<&{LiquidStaking.UnstakingVoucherCollectionPublic}>(LiquidStaking.UnstakingVoucherCollectionPublicPath).borrow()\n        if voucherCollectionRef != nil {\n            // voucherInfos = voucherCollectionRef!.getVoucherInfos()\n            voucherInfos = [\n                {\n                    \"uuid\": 0,\n                    \"lockedFlowAmount\": 12.123,\n                    \"unlockEpoch\": FlowEpoch.currentEpochCounter + 1\n                },\n                {\n                    \"uuid\": 1,\n                    \"lockedFlowAmount\": 1241.212,\n                    \"unlockEpoch\": FlowEpoch.currentEpochCounter\n                }\n            ]\n        }\n    }\n    //let usdcBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(/public/USDCVaultBalance).borrow()!.balance\n    return {\n        \"CurrentEpoch\": FlowEpoch.currentEpochCounter,\n        \"stFlowFlow\": 1.0015, //currentSnapshot.quoteStFlowFlow,\n        \"FlowStFlow\": 0.9985, //currentSnapshot.quoteFlowStFlow,\n        \"FlowUSD\": 2.4,\n\n        \"UnstakingVouchers\": voucherInfos\n    }\n}"
    }
  }
}