{
  "Codes": {
    "Transactions": {
      "Stake": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(flowAmount: UFix64) {\n    prepare(userAccount: AuthAccount) {\n        let flowVault = userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!\n        let inVault <- flowVault.withdraw(amount: flowAmount) as! @FlowToken.Vault\n        \n        let outVault <- LiquidStaking.stake(flowVault: <-inVault)\n\n        var stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        if stFlowVaultRef == nil {\n            userAccount.save(<- stFlowToken.createEmptyVault(), to: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Receiver}>(stFlowToken.tokenReceiverPath, target: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Balance}>(stFlowToken.tokenBalancePath, target: stFlowToken.tokenVaultPath)\n\n            stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        }\n\n        stFlowVaultRef!.deposit(from: <-outVault)\n    }\n}",
      "Unstake": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(stFlowAmount: UFix64) {\n    prepare(userAccount: AuthAccount) {\n        var stFlowVault = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)!\n        let inVault <- stFlowVault.withdraw(amount: stFlowAmount) as! @stFlowToken.Vault\n        \n        let voucher <- LiquidStaking.unstakeSlowly(stFlowVault: <-inVault)\n        log(\"--> unstake slowly stFlow \".concat(stFlowAmount.toString()))\n        log(\"--> could get Flow in the future: \".concat(voucher.lockedFlowAmount.toString()))\n\n        var voucherCollectionRef = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n        if voucherCollectionRef == nil {\n            destroy <- userAccount.load<@AnyResource>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n            userAccount.unlink(LiquidStaking.UnstakingVoucherCollectionPublicPath)\n\n            userAccount.save(<-LiquidStaking.createEmptyUnstakingVoucherCollection(), to: LiquidStaking.UnstakingVoucherCollectionPath)\n            userAccount.link<&{LiquidStaking.UnstakingVoucherCollectionPublic}>(LiquidStaking.UnstakingVoucherCollectionPublicPath, target: LiquidStaking.UnstakingVoucherCollectionPath)\n            voucherCollectionRef = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n        }\n        voucherCollectionRef!.deposit(voucher: <-voucher)\n    }\n}",
      "Claim": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(uuid: UInt64) {\n    prepare(userAccount: AuthAccount) {\n        var voucherCollection = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)!\n        let voucher <-voucherCollection.withdraw(uuid: uuid)\n\n        let flowVault <- LiquidStaking.cashingUnstakingVoucher(voucher: <-voucher)\n        log(\"--> cashing voucher\")\n        log(\"--> get flow: \".concat(flowVault.balance.toString()))\n\n        userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!.deposit(from: <-flowVault)\n    }\n}",
      "Migrate": "import LiquidStaking from 0xf8d6e0586b0a20c7\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowStakingCollection from 0xf8d6e0586b0a20c7\n\ntransaction(nodeID: String, delegatorID: UInt32) {\n    prepare(userAccount: AuthAccount) {\n        let stakingCollectionRef = userAccount.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        let migratedDelegator <- stakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)!\n\n        let outVault <- LiquidStaking.migrate(delegator: <-migratedDelegator)\n\n        log(\"---> migrate mint stFlow\".concat(outVault.balance.toString()))\n\n        var stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        if stFlowVaultRef == nil {\n            userAccount.save(<- stFlowToken.createEmptyVault(), to: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Receiver}>(stFlowToken.tokenReceiverPath, target: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Balance}>(stFlowToken.tokenBalancePath, target: stFlowToken.tokenVaultPath)\n\n            stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        }\n\n        stFlowVaultRef!.deposit(from: <-outVault)\n    }\n}"
    },
    "Scripts": {
      "QueryLiquidStakingInfos": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowIDTableStaking from 0xf8d6e0586b0a20c7\nimport FlowEpoch from 0xf8d6e0586b0a20c7\n\nimport stFlowToken from 0xf8d6e0586b0a20c7\nimport LiquidStaking from 0xf8d6e0586b0a20c7\nimport LiquidStakingConfig from 0xf8d6e0586b0a20c7\nimport DelegatorManager from 0xf8d6e0586b0a20c7\n\npub fun main(userAddr: Address?): {String: AnyStruct} {\n    let currentSnapshot = DelegatorManager.borrowEpochSnapshot(at: DelegatorManager.quoteEpochCounter)\n    let currentBlockView = getCurrentBlock().view\n    let currentEpochMetadata = FlowEpoch.getEpochMetadata(DelegatorManager.quoteEpochCounter)!\n    let showEpochMetadata = FlowEpoch.getEpochMetadata(FlowEpoch.currentEpochCounter)!\n\n    \n    var unlockEpoch = FlowEpoch.currentEpochCounter + 2\n    if FlowIDTableStaking.stakingEnabled() {\n        if currentBlockView + LiquidStakingConfig.windowSizeBeforeStakingEnd >= currentEpochMetadata.stakingEndView {\n            unlockEpoch = FlowEpoch.currentEpochCounter + 3\n        }\n    } else {\n        unlockEpoch = FlowEpoch.currentEpochCounter + 3\n    }\n\n    var voucherInfos: [AnyStruct]? = nil\n    if userAddr != nil {\n        let voucherCollectionRef = getAccount(userAddr!).getCapability<&{LiquidStaking.UnstakingVoucherCollectionPublic}>(LiquidStaking.UnstakingVoucherCollectionPublicPath).borrow()\n        if voucherCollectionRef != nil {\n            // voucherInfos = voucherCollectionRef!.getVoucherInfos()\n            voucherInfos = [\n                {\n                    \"uuid\": 0,\n                    \"lockedFlowAmount\": 12.123,\n                    \"unlockEpoch\": FlowEpoch.currentEpochCounter + 1\n                },\n                {\n                    \"uuid\": 1,\n                    \"lockedFlowAmount\": 1241.212,\n                    \"unlockEpoch\": FlowEpoch.currentEpochCounter\n                }\n            ]\n        }\n    }\n    //let usdcBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(/public/USDCVaultBalance).borrow()!.balance\n    return {\n        \"CurrentEpoch\": DelegatorManager.quoteEpochCounter,\n        \"CurrentUnstakeEpoch\": unlockEpoch,\n\n        \"stFlowFlow\": currentSnapshot.quoteStFlowFlow,\n        \"FlowStFlow\": currentSnapshot.quoteFlowStFlow,\n        \"FlowUSD\": 1.85,\n\n        \"TotalStaked\": DelegatorManager.getTotalValidStakingAmount(),\n        \"APR\": FlowIDTableStaking.getEpochTokenPayout() / FlowIDTableStaking.getTotalStaked() * FlowIDTableStaking.getRewardCutPercentage(),\n\n        \"EpochMetadata\": {\n            \"StartView\": showEpochMetadata.startView,\n            \"StartTimestamp\": currentSnapshot.quoteEpochStartTimestamp,\n            \"EndView\": showEpochMetadata.endView,\n            \"CurrentView\": currentBlockView,\n            \"CurrentTimestamp\": getCurrentBlock().timestamp,\n            \"StakingEndView\": showEpochMetadata.stakingEndView\n        },\n\n        \"User\": {\n            \"UnstakingVouchers\": voucherInfos,\n            \"MigratedInfos\": {\n                \"lockedTokensUsed\": 90.0,\n                \"unlockedTokensUsed\": 83.0,\n                \"migratedInfos\": [\n                    {\n                        \"nodeID\": \"121132\",\n                        \"id\": 123,\n                        \"tokensCommitted\": 10.0,\n                        \"tokensStaked\": 10.0,\n                        \"tokensUnstaking\": 10.0,\n                        \"tokensRewarded\": 10.0,\n                        \"tokensUnstaked\": 10.0,\n                        \"tokensRequestedToUnstake\": 10.0\n                    }\n                ]\n            }\n        }\n    }\n}"
    }
  }
}