{
  "Codes": {
    "Transactions": {
      "stake": "import LiquidStaking from 0x412d895285190a7a\nimport stFlowToken from 0x412d895285190a7a\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(flowAmount: UFix64) {\n    prepare(userAccount: AuthAccount) {\n        let flowVault = userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!\n        let inVault <- flowVault.withdraw(amount: flowAmount) as! @FlowToken.Vault\n        \n        let outVault <- LiquidStaking.stake(flowVault: <-inVault)\n        \n        var stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        if stFlowVaultRef == nil {\n            userAccount.save(<- stFlowToken.createEmptyVault(), to: stFlowToken.tokenVaultPath)\n            userAccount.unlink(stFlowToken.tokenReceiverPath)\n            userAccount.unlink(stFlowToken.tokenBalancePath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Receiver}>(stFlowToken.tokenReceiverPath, target: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Balance}>(stFlowToken.tokenBalancePath, target: stFlowToken.tokenVaultPath)\n\n            stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        }\n\n        stFlowVaultRef!.deposit(from: <-outVault)\n    }\n}",
      "unstakeSlowly": "import LiquidStaking from 0x412d895285190a7a\nimport stFlowToken from 0x412d895285190a7a\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(stFlowAmount: UFix64) {\n    prepare(userAccount: AuthAccount) {\n        var stFlowVault = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)!\n        let inVault <- stFlowVault.withdraw(amount: stFlowAmount) as! @stFlowToken.Vault\n        \n        let voucher <- LiquidStaking.unstakeSlowly(stFlowVault: <-inVault)\n        log(\"--> unstake slowly stFlow \".concat(stFlowAmount.toString()))\n        log(\"--> could get Flow in the future: \".concat(voucher.lockedFlowAmount.toString()))\n\n        var voucherCollectionRef = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n        if voucherCollectionRef == nil {\n            destroy <- userAccount.load<@AnyResource>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n            userAccount.unlink(LiquidStaking.UnstakingVoucherCollectionPublicPath)\n\n            userAccount.save(<-LiquidStaking.createEmptyUnstakingVoucherCollection(), to: LiquidStaking.UnstakingVoucherCollectionPath)\n            userAccount.link<&{LiquidStaking.UnstakingVoucherCollectionPublic}>(LiquidStaking.UnstakingVoucherCollectionPublicPath, target: LiquidStaking.UnstakingVoucherCollectionPath)\n            voucherCollectionRef = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)\n        }\n        voucherCollectionRef!.deposit(voucher: <-voucher)\n    }\n}",
      "unstakeCashing": "import LiquidStaking from 0x412d895285190a7a\nimport stFlowToken from 0x412d895285190a7a\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(uuid: UInt64) {\n    prepare(userAccount: AuthAccount) {\n        var voucherCollection = userAccount.borrow<&LiquidStaking.UnstakingVoucherCollection>(from: LiquidStaking.UnstakingVoucherCollectionPath)!\n        let voucher <-voucherCollection.withdraw(uuid: uuid)\n\n        let flowVault <- LiquidStaking.cashingUnstakingVoucher(voucher: <-voucher)\n        log(\"--> cashing voucher\")\n        log(\"--> get flow: \".concat(flowVault.balance.toString()))\n\n        userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!.deposit(from: <-flowVault)\n    }\n}",
      "migrate": "import LiquidStaking from 0x412d895285190a7a\nimport stFlowToken from 0x412d895285190a7a\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\ntransaction(nodeID: String, delegatorID: UInt32) {\n    prepare(userAccount: AuthAccount) {\n        let stakingCollectionRef = userAccount.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        let migratedDelegator <- stakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)!\n\n        let outVault <- LiquidStaking.migrate(delegator: <-migratedDelegator)\n\n        log(\"---> migrate mint stFlow\".concat(outVault.balance.toString()))\n\n        var stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        if stFlowVaultRef == nil {\n            userAccount.save(<- stFlowToken.createEmptyVault(), to: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Receiver}>(stFlowToken.tokenReceiverPath, target: stFlowToken.tokenVaultPath)\n            userAccount.link<&stFlowToken.Vault{FungibleToken.Balance}>(stFlowToken.tokenBalancePath, target: stFlowToken.tokenVaultPath)\n\n            stFlowVaultRef = userAccount.borrow<&stFlowToken.Vault>(from: stFlowToken.tokenVaultPath)\n        }\n\n        stFlowVaultRef!.deposit(from: <-outVault)\n    }\n}"
    },
    "Scripts": {
      "queryUserInfo": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowIDTableStaking from 0x9eca2b38b18b5dfe\nimport FlowEpoch from 0x9eca2b38b18b5dfe\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\nimport stFlowToken from 0x412d895285190a7a\nimport LiquidStaking from 0x412d895285190a7a\nimport LiquidStakingConfig from 0x412d895285190a7a\nimport DelegatorManager from 0x412d895285190a7a\n\npub fun main(userAddr: Address?): {String: AnyStruct} {\n    let currentSnapshot = DelegatorManager.borrowEpochSnapshot(at: DelegatorManager.quoteEpochCounter)\n    let currentBlockView = getCurrentBlock().view\n    let currentEpochMetadata = FlowEpoch.getEpochMetadata(DelegatorManager.quoteEpochCounter)!\n    let showEpochMetadata = FlowEpoch.getEpochMetadata(DelegatorManager.quoteEpochCounter)!\n\n    var unlockEpoch = FlowEpoch.currentEpochCounter + 2\n    if FlowIDTableStaking.stakingEnabled() {\n        if currentBlockView + LiquidStakingConfig.windowSizeBeforeStakingEnd >= currentEpochMetadata.stakingEndView {\n            unlockEpoch = FlowEpoch.currentEpochCounter + 3\n        }\n    } else {\n        unlockEpoch = FlowEpoch.currentEpochCounter + 3\n    }\n\n    // voucher\n    var voucherInfos: [AnyStruct]? = nil\n    if userAddr != nil {\n        let voucherCollectionRef = getAccount(userAddr!).getCapability<&{LiquidStaking.UnstakingVoucherCollectionPublic}>(LiquidStaking.UnstakingVoucherCollectionPublicPath).borrow()\n        if voucherCollectionRef != nil {\n            voucherInfos = voucherCollectionRef!.getVoucherInfos()\n        }\n    }\n\n    // migrate info\n    var lockedTokensUsed = 0.0\n    var unlockedTokensUsed = 0.0\n    var migratedInfos: [AnyStruct]? = nil\n    if userAddr != nil {\n        let stakingCollectionRef = getAccount(userAddr!).getCapability<&{FlowStakingCollection.StakingCollectionPublic}>(FlowStakingCollection.StakingCollectionPublicPath).borrow()\n        if stakingCollectionRef != nil {\n            migratedInfos = stakingCollectionRef!.getAllDelegatorInfo()\n            lockedTokensUsed = stakingCollectionRef!.lockedTokensUsed\n            unlockedTokensUsed = stakingCollectionRef!.unlockedTokensUsed\n        }\n    }\n\n    return {\n        \"CurrentEpoch\": DelegatorManager.quoteEpochCounter,\n        \"CurrentUnstakeEpoch\": unlockEpoch,\n\n        \"stFlowFlow\": currentSnapshot.quoteStFlowFlow,\n        \"FlowStFlow\": currentSnapshot.quoteFlowStFlow,\n        \n        \"TotalStaked\": DelegatorManager.getTotalValidStakingAmount(),\n        \"APR\": FlowIDTableStaking.getEpochTokenPayout() / FlowIDTableStaking.getTotalStaked() * FlowIDTableStaking.getRewardCutPercentage(),\n\n        \"EpochMetadata\": {\n            \"StartView\": showEpochMetadata.startView,\n            \"StartTimestamp\": currentSnapshot.quoteEpochStartTimestamp,\n            \"EndView\": showEpochMetadata.endView,\n            \"CurrentView\": currentBlockView,\n            \"CurrentTimestamp\": getCurrentBlock().timestamp,\n            \"StakingEndView\": showEpochMetadata.stakingEndView\n        },\n\n        \"User\": {\n            \"UnstakingVouchers\": voucherInfos,\n            \"MigratedInfos\": {\n                \"lockedTokensUsed\": lockedTokensUsed,\n                \"unlockedTokensUsed\": unlockedTokensUsed,\n                \"migratedInfos\": migratedInfos\n            }\n        }\n    }\n}"
    }
  }
}